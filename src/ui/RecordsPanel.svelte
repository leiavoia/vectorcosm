<script>

	import { onMount, onDestroy } from 'svelte';
	import Chart from 'chart.js/auto';
	
	let {records, open=true} = $props();
	
	let chartcanvas;
    let simulatorChart;
	let layerOnDisplay = $state(0); 
	let recordsPerLayer = 30; 
	const datasets = []; // used by the chart. data copied from records trackers
	const chartlabels = []; // used by the chart. "labels" are actually timestamps or turns
					
	Chart.defaults.color = '#FFF';
	Chart.defaults.backgroundColor = '#000000AA';
	Chart.defaults.elements.line.backgroundColor = '#41A34F';
	Chart.defaults.elements.line.borderColor = '#41A34F';
	Chart.defaults.elements.bar.backgroundColor = '#41A34F';
	Chart.defaults.elements.bar.borderColor = '#41A34F';
	Chart.defaults.elements.point.radius = 0;
			 
	onMount(() => {
		simulatorChart = MakeSimulatorChart(chartcanvas, records);
		preloadChartData(records);
		simulatorChart.update(); // render manually
		// subscribe to tracker events if we havent already
		if ( !records?.onInsert ) {
			records.onInsert = ( data, layer ) => {
				// update graph if the layer that got the insert is the layer we are watching
				if ( layer == layerOnDisplay ) {
					// update each stat - TODO: could be optimized for speed
					for ( let k in data ) {
						// find the dataset that matches the record key
						const dataset = datasets.find( d => d.label == k );
						if ( dataset ) {
							while ( dataset.data.length >= recordsPerLayer ) {
								dataset.data.shift();
							}
							dataset.data.push( data[k] );
						}
					}
					// add another label to push the chart forward
					const next_index = chartlabels.length-1;
					const next_label = next_index < 0 ? 0 : chartlabels[ next_index ];
					while ( chartlabels.length >= recordsPerLayer ) {
						chartlabels.shift();
					}
					chartlabels.push( next_label );
					// trigger the visual update
					simulatorChart.update(); 
				}
			};
		}
	});
			
	onDestroy(() => {
		records.onInsert = null;
	})	
	
	// use this function to load chart data from the tracker 
	// when the widget is created in order to present a complete chart		
	function preloadChartData( records ) {
		 chartlabels.length = 0; // reset chart labels
		 // loop through each chart dataset, find the matching tracker by name,
		 for ( let ds of datasets ) {
			const tracker = records.trackers[ds.label];
			if ( tracker ) {
				// get the data for the current layer
				const data = tracker.layers[layerOnDisplay];
				if ( data ) {
					// copy the data into the dataset
					ds.data = data.slice(0, recordsPerLayer);
					// add the labels if they don't exist
					if ( chartlabels.length == 0 ) {
						// create labels based on the data length
						for ( let i = 0; i < ds.data.length; i++ ) {
							chartlabels.push( i );
						}
					}
				}
			}
		 }			 
	}
			
	function MakeSimulatorChart( element, records ) {
		
		const colors = [
			'#FF6F61', // coral red
			'#6FCF97', // green
			'#56CCF2', // blue
			'#F2C94C', // yellow
			'#45B8AC', // teal
			'#BB6BD9', // purple
			'#F2994A', // orange
			'#2D9CDB', // azure
			'#27AE60', // emerald
			'#EB5757', // crimson
			'#9B51E0', // violet
			'#F7B731', // gold
			'#00B894', // turquoise
			'#0984E3', // sapphire
			'#FD7272', // pink
			'#00CEC9', // aqua
			'#636E72', // slate
			'#E17055', // salmon
			'#B2BEC3', // silver
			'#D35400', // pumpkin
		];
		let next_color = 0;
		
		// we need to create each dataset with its own y axis
		const axes = {
			x: { display: false },
			// add named y axes as we go
		};
		
		// these datasets are on by default. all others must be toggled on
		const visible_datasets = [/* 'boids','foods', */'boid_mass','food_mass'];
		
		// create the data sets based on record trackers.
		// each tracker tracks a set of named statistics.
		// each stat has 4 layers of data (fine grained to general)
		for ( let k in records.trackers ) {
			// create an independent Y Axis
			const yAxisID = `y-${k}`;
			axes[yAxisID] = {
				type: 'linear',
                position: 'left',
				display: false
			};
			// create the dataset
			const dataset = {
				label: k,
				data: [], // will populate later
				// order: (next_color+1),
				backgroundColor: colors[next_color % colors.length],
				borderColor: colors[next_color % colors.length],
				borderWidth: 2,
				fill:false,
				tension: 0.2,
				yAxisID: yAxisID,
				hidden: !visible_datasets.contains(k)
			};
			datasets.push(dataset);
			++next_color;
		}
		
		// define a custom plugin to paint the chart background color
		const customBackgroundColorPlugin = {
			id: 'customBackgroundColor',
			beforeDraw: (chart, args, options) => {
				const ctx = chart.ctx;
				const chartArea = chart.chartArea;
				if (chartArea) {
					ctx.save();
					ctx.globalCompositeOperation = 'destination-over';
					ctx.fillStyle = options.color || '#000';
					ctx.fillRect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
					ctx.restore();
				}
			}
		};
		
		// options and setup
		const chartdata = { labels: chartlabels, datasets };
		const chartconfig = {
			type: 'line',
			data: chartdata,
			plugins: [customBackgroundColorPlugin],
			options: {
				responsive: false,
				aspectRatio: 2.5,
				interaction: {
					intersect: false,
				},
				plugins: {
					customBackgroundColor: { color: '#00000055'},
					legend: {
						position: 'bottom',
						display:true,
						labels: {
							color: '#FFFFFF',
							// font: {
								// size: 10,
								// weight: 'bold'
							// },
							boxWidth: 10,
							boxHeight: 10,
							padding: 10,
							usePointStyle: false,
							// generateLabels: (chart) => {
							// 	// generate labels for the legend
							// 	return chart.data.datasets.map((dataset, index) => {
							// 		return {
							// 			text: dataset.label,
							// 			fillStyle: dataset.backgroundColor,
							// 			strokeStyle: dataset.borderColor,
							// 			lineWidth: dataset.borderWidth,
							// 			index: index
							// 		};
							// 	});
							// }
						}
					},
					title: {
						display: false,
					}
				},
				scales: axes				
			}
		};
		return new Chart( element.getContext('2d'), chartconfig );
	}
					
	function SwitchLayer(layer) {
		layerOnDisplay = layer;
		preloadChartData(records);
		simulatorChart.update(); 
	}
	
</script>

<style>
	
</style>

<section class={{nocontent:!open}}>
	<header onclick={()=>open=!open}>
		<h3>Records</h3>
	</header>
	<!-- note: we can't remove this from the dom because the chart needs to remain available for updates even when hidden -->
	<div style="display: {open ? 'block' : 'none'}">
		<div class="button_rack">
			<button onclick={()=>SwitchLayer(0)} class={{outline:layerOnDisplay!==0}}>Short</button>
			<button onclick={()=>SwitchLayer(1)} class={{outline:layerOnDisplay!==1}}>Medium</button>
			<button onclick={()=>SwitchLayer(2)} class={{outline:layerOnDisplay!==2}}>Long</button>
			<button onclick={()=>SwitchLayer(3)} class={{outline:layerOnDisplay!==3}}>Epoch</button>
		</div>
		<!-- <div> -->
			<canvas bind:this={chartcanvas} style="
				width: 100%; 
				height: 18em; 
				margin-top:1rem; 
			"></canvas> 
		<!-- </div> -->
	</div>
</section>	

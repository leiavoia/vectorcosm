
<!doctype html>
<html>
<head>
	<title>Vectorcosm</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			font-family: "Lato";
			font-weight: 300;
			overflow: hidden;
			background: #000 linear-gradient( to top, #000 0%, #000 50%, #048 80%, #06A 100% );
			background-attachment: fixed;
			background-size: cover
		}

		#draw-shapes {
			width: 100vw;
			height: 100vh;
			/* margin: 2.5% auto; */
			/* border: 1px solid #999; */
		}
		
		#shape-container { 
			/* border: 1px solid #999;  */
			width: 100vw;
			height: 100vh;
		}
		INPUT[type=range] { margin-right:0.5em; }
		OUTPUT { color: #55EEFF; }
		LABEL {
			width: 4em;
			display:inline-block;
			text-align:left;
		}
		.ui {
			color:white; 
			position: fixed; 
			left:1em; 
			top:1em; 
			z-index: 10; 
			font-size: 1.5em; 
			line-height: 1.5em;
			visibility: visible;
		}
		.ui.hidden { visibility: hidden; }
	</style>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/two.js/0.8.10/two.min.js"></script>
	<script src="https://wagenaartje.github.io/neataptic/cdn/1.4.7/neataptic.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.5.1/chart.min.js"></script>
	<script src="https://unpkg.com/delaunator@5.0.0/delaunator.min.js"></script>

	<link rel="canonical" href="https://leiavoia.net/cogmind/dataminer/" />
	<meta name="description" content="AI Aquarium for Digital Lifeforms" />
	<meta name="keywords" content="AI,fish,aquarium" />
	<meta name="author" content="leiavoia" />
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<!-- <link rel="icon" type="image/x-icon" href="img/favicon.ico" sizes="16x16" /> -->
	<!-- dev version -->
	<!-- <script src="https://unpkg.com/vue"></script> -->
	<!-- prod version -->
	<!-- <script src="https://unpkg.com/vue@2.6.14/dist/vue.min.js"></script> -->
	
	<meta charset="UTF-8">
</head>


<body id="body">
	<div class="shape-container">
		<div id="draw-shapes"></div>
	</div>
	
	<div class="ui" id="ui_container">
		<button id="pause_button">Pause</button>
		<button id="fast_forward_button">FF</button>
		<button id="hide_ui_button">UI</button>
		<button id="show_sensors_button">Sensors</button>
		<button id="show_brainmap_button">Brain</button>
		<button id="save_leader_button">Save</button>
		<button id="load_leader_button">Load</button>
		
		<br />
		
		<label for="numboids_slider">Boids</label>
		<input type="range" min="0" max="250" step="1" style="margin-bottom:-0.25em;" onChange="ChangeNumBoids()" id="numboids_slider" />
		<output for="numboids_slider" id="numboids_slider_output"></output>
		
		<br/>
		
		<label for="mutation_slider">Mutation</label>
		<input type="range" min="1" max="10" step="1" style="margin-bottom:-0.25em;" onChange="ChangeMutation()" id="mutation_slider" />
		<output for="mutation_slider" id="mutation_slider_output"></output>
		
		<br/>
		
		<label for="culling_slider">Culling</label>
		<input type="range" min="0.1" max="0.9" step="0.1" style="margin-bottom:-0.25em;" onChange="ChangeCulling()" id="culling_slider" />
		<output for="culling_slider" id="culling_slider_output"></output>
		
		<br/>
		
		<label for="viscosity_slider">Viscosity</label>
		<input type="range" min="0" max="1" step="0.01" style="margin-bottom:-0.25em;" onChange="ChangeViscosity()" id="viscosity_slider" />
		<output for="viscosity_slider" id="viscosity_slider_output"></output>
		
		<br/>
		
		<!-- works, but not the right time for this in the UI -->
		<label for="world_scale_slider">Scale</label>
		<input type="range" min="0.1" max="2" step="0.1" style="margin-bottom:-0.25em;" onChange="SetViewScale(this.value)" id="world_scale_slider" />
		<output for="world_scale_slider" id="world_scale_slider_output"></output>
		
		<br/>
		
				
		Round: <output id="round_output">0</output> | 
		Best: <output id="best_score_output">0</output> | 
		Avg: <output id="avg_score_output">0</output>
		
		<br />
		
		Sim Best: <output id="total_score_output">0</output> | 
		Best Avg: <output id="best_avg_score_output">0</output>
		
		<br/>
		
		Frame: <output id="framenum_output">0</output> | 
		FPS: <output id="fps_output">0</output>
		
		<br/>
		
		<canvas id="simulatorChart" style="width: 12em; height: 4em;"></canvas>
       
	  
	</div>
	
	<script>
		// set up Two.js
		let elem = document.getElementById('draw-shapes');
		let two = new Two({ fitted: true }).appendTo(elem);
		two.bind('update', update);

		// set up neataptic
		const { architect, Network, methods, config } = neataptic;
		const mutation_options =  [
			methods.mutation.ADD_NODE,
			methods.mutation.SUB_NODE,
			methods.mutation.ADD_CONN,
			methods.mutation.SUB_CONN,
			methods.mutation.MOD_WEIGHT,
			methods.mutation.MOD_BIAS,
			methods.mutation.MOD_ACTIVATION,
			methods.mutation.ADD_GATE,
			methods.mutation.SUB_GATE,
			methods.mutation.ADD_SELF_CONN,
			methods.mutation.SUB_SELF_CONN,
			methods.mutation.ADD_BACK_CONN,
			methods.mutation.SUB_BACK_CONN
		];
						
		// world settings
		let world = {
			use_species: 'Boid',
			settings: { 
				viscosity: 0.22, // 0..1
				max_mutation: 5, // up to
				cullpct: 0.8, // 0..1
			},
			ui: {
				show_collision_detection: false,
				show_ui: true,
				show_brainmap: false,
				focus_object: null,
				focus_geo: null
			},
			width: two.width * 2,
			height: two.height * 2,
			scale: 0.5,
			simulator: {
				turbo: false,
				turns: 3000,
				rounds: 5000,
				best_score: 0,
				best_avg_score: 0,
				best_brain: null,
				round: {
					num: 0,
					best_score: 0,
					avg_score: 0,
				},
				chartdata: {
					averages: [],
					highscores: []
				}
			}
		};
		
		// default scale depends on device you are on
		function SetViewScale( scale ) {
			world.scale = clamp( scale, 0.1, 10 );
			world.width =  two.width / world.scale,
			world.height =  two.height / world.scale,
			two.scene.scale = world.scale;
			document.getElementById('world_scale_slider').value = world.scale;
			document.getElementById('world_scale_slider_output').value = world.scale;
		}
		if ( two.width < 500 ) { SetViewScale(0.4); }
		else if ( two.width < 1200 ) { SetViewScale(0.6); }
		else if ( two.width < 1900 ) { SetViewScale(1); }
		else { SetViewScale(1); }
		
		// graphing and chart setup				
		Chart.defaults.color = '#FFF';
		Chart.defaults.elements.line.backgroundColor = '#41A34F';
		Chart.defaults.elements.line.borderColor = '#41A34F';
		Chart.defaults.elements.bar.backgroundColor = '#41A34F';
		Chart.defaults.elements.bar.borderColor = '#41A34F';
		Chart.defaults.elements.point.radius = 0;
		const chartdata = {
			labels: [],
			datasets: [
				{
					label: 'Average',
					backgroundColor: '#3DAEE9',
					borderColor: '#3DAEE9',
					borderWidth: 1,
					fill:true,
					data: world.simulator.chartdata.averages,
					order: 2,
					tension: 0.2,
				},
				{
					label: 'Best',
					backgroundColor: '#55EEFF33',
					borderColor: '#55EEFF33',
					borderWidth: 1,
					fill:true,
					tension: 0.2,
					data: world.simulator.chartdata.highscores,
				},
			]
		};
		const chartconfig = {
			type: 'line',
			data: chartdata,
			options: {
				responsive: false,
				aspectRatio: 2.5,
				interaction: {
					intersect: false,
				},					
				plugins: {
					legend: {
						position: 'top',
						display:false,
					},
					title: {
						display: false,
					}
				},
				scales: {
					x: { display: false },
					y: { display: false }
				}				
			}
		};
		let simulatorChart = new Chart( document.getElementById('simulatorChart'), chartconfig );

		// background layer
		function MakeBackground() {
			let bgnumpts = Math.trunc(Math.random() * 200) + 10;
			let bgpts = [];
			bgpts.push( [0, 0] );
			bgpts.push( [world.width, 0] );
			bgpts.push( [0, world.height] );
			bgpts.push( [world.width, world.height] );
			for ( let x=0; x < bgnumpts*0.1; x++ ) {
				bgpts.push( [Math.trunc(Math.random() * world.width), 0] );
				bgpts.push( [Math.trunc(Math.random() * world.width), world.height] );
			}
			for ( let x=0; x < bgnumpts*0.1; x++ ) {
				bgpts.push( [0, Math.trunc(Math.random() * world.height)] );
				bgpts.push( [world.width, Math.trunc(Math.random() * world.height) ] );
			}
			for ( let x=0; x < bgnumpts*0.8; x++ ) {
				bgpts.push( [ Math.trunc(Math.random() * world.width), Math.trunc(Math.random() * world.height)] );
			}

			let color_schemes = [
				['#333333','#333333','#333333'], // solid grey
				['#0a0a0a','#111111','#1a1a1a'], // basalt
				['#07290C','#001B04','transparent'], // kelpgarden
				['#07290C','#001B04','#0C1F01'], // mossgarden
			];
			const delaunay = Delaunator.from(bgpts);
			let triangles = delaunay.triangles;
			bgcolors = color_schemes[ Math.trunc( Math.random() * color_schemes.length ) ];
			let bggroup = two.makeGroup();
			for (let i = 0; i < triangles.length; i += 3) {
				let c = bgcolors[ Math.trunc( Math.random() * bgcolors.length ) ]; 
				
				// fades up the tank 
				const color_variance = 0.9;
				let center = (bgpts[triangles[i]][1] + bgpts[triangles[i+1]][1] + bgpts[triangles[i+2]][1]) / 3;
				const r = (0.5-(center/world.height)) * color_variance + (Math.random()*color_variance*0.5-0.5); 
				c = adjustColor(c,r);
				
				// random shift
				// const color_variance = 0.2;
				// const r = Math.random() * color_variance;
				// c = adjustColor(c, 2 * r - r); // +/- the amount
				
				let t = two.makePath(
					bgpts[triangles[i]][0], 
					bgpts[triangles[i]][1], 
					bgpts[triangles[i+1]][0], 
					bgpts[triangles[i+1]][1], 
					bgpts[triangles[i+2]][0], 
					bgpts[triangles[i+2]][1] 
					);
				t.linewidth = 2;
				t.fill = c;
				t.stroke = c;
				bggroup.add(t);
			}		
			let randscale = Math.random() * 9 + 1;
			let xory = Math.random() > 0.5;
			bggroup.scale = new Two.Vector( xory ? randscale : 1.5, xory ? 1.5 : randscale );
			// basalt cliffs:
			// bggroup.scale = new Two.Vector(1,10);
			// shale:
			// bggroup.scale = new Two.Vector(8,1);
		}
		MakeBackground();


		function adjustColor(color, percent) {
			if ( !color.match(/#*[A-E0-9]{3,8}/i) ) { return color; }
			color = color.replace('#','').trim();
			// convert shorthand to longhand
			if ( color.length <= 4 ) {
				color = color.split('').map( p => p+p ).join('');
			}
					
			// Parse the color string into its individual RGB components
			const red = parseInt(color.slice(0, 2), 16);
			const green = parseInt(color.slice(2, 4), 16);
			const blue = parseInt(color.slice(4, 6), 16);
			const alpha = color.slice(6, 8);

			// Calculate the new RGB values
			const newRed = Math.trunc(red + (red*percent));
			const newGreen = Math.trunc(green + (green*percent));
			const newBlue = Math.trunc(blue + (blue*percent));

			// Clamp the RGB values to ensure they are within the valid range of 0-255
			const clampedRed = Math.max(0, Math.min(255, newRed));
			const clampedGreen = Math.max(0, Math.min(255, newGreen));
			const clampedBlue = Math.max(0, Math.min(255, newBlue));

			// Convert the new RGB values back to a color string
			const adjustedColor = "#" +
				clampedRed.toString(16).padStart(2, '0') +
				clampedGreen.toString(16).padStart(2, '0') +
				clampedBlue.toString(16).padStart(2, '0') + 
				alpha
				;

			return adjustedColor;
		}

		class Plant {
			constructor(x=0,y=0,scale=1) {
				scale = clamp(scale,0.1,10);
				this.x = x;
				this.y = y;
				let leaves = Math.trunc( Math.random() * 2 ) + 2;
				this.geo = two.makeGroup();
				for ( let i=0; i < leaves; i++ ) {
					let h = Math.random()*400*scale + 200;
					let w = Math.random()*300*scale + 200;
					let tip_x = x + ((w * Math.random() * 0.6) - (w * Math.random() * 0.3));
					let points = [
						(x + (Math.random() * 60 * scale)) - (30*scale), // root
						y+50,
						Math.max(x,tip_x) + Math.random() * w / 2,
						y - (Math.random() * h/2 + h/2),
						tip_x,
						y-h,
						Math.min(x,tip_x) - Math.random() * w / 2,
						y - (Math.random() * h/2 + h/2)
					];
					let path = two.makePath(...points);
					path.linewidth = 2;
					path.stroke = adjustColor('#AEA1',0.1);
					path.fill = adjustColor('#AEA2',0.1);
					this.geo.add( path );
				}
			}
		}
		
		let num_plants = 7;
		for ( let i=0; i < num_plants; i++ ) {
			let plant = new Plant(
				(Math.random()*world.width + Math.random()*world.width) / 2,
				world.height,
				(Math.random() * 2 + 0.5)
				);
		}
		
		class Food {
			constructor(x=0,y=0) {
				this.x = x;
				this.y = y;
				this.vx = Math.random() * 10 - 5;
				this.vy = Math.random() * 100 - 50;
				this.value = 80;
				this.r = this.value;
				this.geo = two.makePolygon(this.x,this.y,this.r,9);
				this.geo.linewidth = 2;
				this.geo.stroke = '#FA0';
				this.geo.fill = 'transparent';
				this.dead = false;			
			}
			Update(delta) {
				const margin = 300;
				if ( !delta ) { return; }
				if ( delta > 1 ) { delta /= 1000; }
				this.x += this.vx * delta;
				this.y += this.vy * delta;
				if ( this.x < margin ) { this.vx = -this.vx; }
				if ( this.y < margin ) { this.vy = -this.vy; }
				if ( this.x > world.width-margin ) { this.vx = -this.vx; }
				if ( this.y > world.height-margin ) { this.vy = -this.vy; }
				this.x = clamp( this.x, margin, world.width-margin );
				this.y = clamp( this.y, margin, world.height-margin );
				// update the object in space
				this.geo.position.x = this.x;
				this.geo.position.y = this.y;
				this.geo.radius = this.value;
			}
			Eat(amount) { 
				this.value -= amount;
				if ( this.value <= 0 ) { 
					this.Kill();
					foods.push(new Food(
						(Math.random() * world.width*0.5) + (world.width*0.25),
						(Math.random() * world.height*0.5) + (world.height*0.25)
					));
				}
			}
			Kill() {
				two.remove([this.geo]);
				this.dead = true;
				let i = foods.indexOf(this);
				if ( i >= 0 ) { foods.splice(i,1); }
			}			
		}
		
		class Poison {
			constructor(x=0,y=0) {
				this.x = x;
				this.y = y;
				this.vx = Math.random() * 10 - 5;
				this.vy = Math.random() * 100 - 50;
				this.value = 70;
				this.r = this.value;
				this.geo = two.makePolygon(this.x,this.y,this.r,8);
				this.geo.linewidth = 2;
				this.geo.stroke = '#FAF';
				this.geo.fill = 'transparent';
				this.dead = false;			
			}
			Update(delta) {
				const margin = 200;
				if ( !delta ) { return; }
				if ( delta > 1 ) { delta /= 1000; }
				this.x += this.vx * delta;
				this.y += this.vy * delta;
				if ( this.x < margin ) { this.vx = -this.vx; }
				if ( this.y < margin ) { this.vy = -this.vy; }
				if ( this.x > world.width-margin ) { this.vx = -this.vx; }
				if ( this.y > world.height-margin ) { this.vy = -this.vy; }
				this.x = clamp( this.x, margin, world.width-margin );
				this.y = clamp( this.y, margin, world.height-margin );
				// update the object in space
				this.geo.position.x = this.x;
				this.geo.position.y = this.y;
				this.geo.radius = this.value;
			}
			Kill() {
				two.remove([this.geo]);
				this.dead = true;
				let i = foods.indexOf(this);
				if ( i >= 0 ) { foods.splice(i,1); }
			}			
		}

		let foods = [ 
			new Food(
				(Math.random() * world.width*0.5) + (world.width*0.25),
				(Math.random() * world.height*0.5) + (world.height*0.25)
			),
		];
		
		let threats = [
			// new Poison(world.width*0.2,world.height*0.8),
		];
		
		function BoidFactory( type, x, y ) {
			if ( type == 'Kayak' ) { return new Kayak(x,y); }
			if ( type == 'Simpleton' ) { return new Simpleton(x,y); }
			if ( type == 'Boid' ) { return new Boid(x,y); }
			// random!
			let n = Math.random(); 
			if ( n > 0.67 ) { return new Simpleton(x,y); }
			if ( n > 0.33 ) { return new Kayak(x,y); }
			return new Boid(x,y);
		}
		
		class ProtoBoid {
			constructor( x=0, y=0 ) {
				this.species = 'prototype';
				// physical stuff
				this.energy = 0;
				this.x = x;
				this.y = y;
				// this.momentum_x = 0; // use momentum with the momentum_based code in Update()
				// this.momentum_y = 0;
				this.maxspeed = 600;
				this.maxrot = 8;
				this.angle = Math.random()*Math.PI*2;
				this.length = 30;
				this.width = 15;
				this.inertia = 0; // forward motion power, can be negative
				this.angmo = 0; // angular momentum / rotational inertia
				this.energy_cost = 0.15;
				// drawing stuff
				this.path = null;
				this.container = two.makeGroup();
				this.container.position.x = x;
				this.container.position.y = y;
				this.container.add([this.path]);
				this.container.visible = true;
				// neuro stuff
				this.brain = null;
				// vision and sensors
				this.sensors = [];
				this.sensor_score = 0; // per frame
				this.total_sensor_score = 0; // accumulates over time
				this.sensor_group = two.makeGroup();
				this.sensor_group.linewidth = 1;
				this.sensor_group.stroke = '#AAEEAA55';
				this.sensor_group.fill = 'transparent';
				this.sensor_group.visible = world.ui.show_collision_detection;
				this.container.add(this.sensor_group);
			}
			MakeGeometry() { }
			MakeMotors() {}
			MakeSensors() { }
			MakeBrain( inputs, middles, outputs, connections ) {
				// training_data.push( { input: sensors, output: [expect] } );
				// const result = net.train(CreateTrainingData(10000), options);
				// this.brain = architect.Random(inputs, middles, outputs, {
				// 	connections: connections,
				// 	gates: 4,
				// 	selfconnections: 4
				// 	});			
				this.brain = architect.Perceptron(inputs, middles, outputs);			
			}
			NeuroInputs() { return []; }
			Update( delta ) {
				if ( !delta ) { return; }
				// sensor collision detection
				let sinAngle = Math.sin(this.angle);
				let cosAngle = Math.cos(this.angle);				
				this.sensor_score = 0;
				for ( let s of this.sensors ) {
					s.val = 0;
					let sx = this.x + ((s.x * cosAngle) - (s.y * sinAngle));
					let sy = this.y + ((s.x * sinAngle) + (s.y * cosAngle));
					for ( let food of foods ) { 
						const dx = Math.abs(food.x - sx);
						const dy = Math.abs(food.y - sy);
						const d = Math.sqrt(dx*dx + dy*dy);
						s.val += clamp( 1 - (d / (s.r + food.r)), 0, 1 );
						// if this is the inner touch sensor, we also "eat" the food
						if ( s.type=="touch" && d <= s.r + food.r ) {
							food.Eat(delta);
						}
					}
					this.sensor_score += s.val;
					s.geo.fill = s.val ? `rgba(150,255,150,${s.val*0.5})` : 'transparent';
				}
				this.sensor_score /= this.sensors.length;
				this.total_sensor_score += this.sensor_score * delta * 18; // the extra padding is just to make numbers look good
				if ( this.sensors.filter(s=>s.val).length ) {
					let c = HexColorToRGBArray(this.path.stroke);
					this.path.fill = `rgba(${c[0]},${c[1]},${c[2]},${this.sensor_score*2})`;
				}
				else { this.path.fill = 'transparent'; }
				
				// UI: toggle collision detection geometry UI
				this.sensor_group.visible = world.ui.show_collision_detection;
				
				// movement / motor control 				
				this.energy += delta + Math.random() * delta;
				this.energy = Math.min( this.energy, this.max_energy || 1.0 );
				if ( this.energy >= this.energy_cost ) {
					this.energy -= this.energy_cost;
					const outputs = this.brain.activate( this.NeuroInputs() );
					// activate all motors at once, even if it seems contradictory
					for ( let i=0; i < outputs.length; i++ ) {
						this.ActivateMotor( i, clamp(outputs[i],0,1) );
					}
				}
				// update position with movement:
				// - The object has angular momentum that changes its pointing angle.
				// - Intertia and angle determine the direction of power generated by motors in pixels per second.
				// - Momentum is the force of direction of the object as a whole, in x/y pixels per second
				
				// MOMENTUM BASED MOVEMENT:
				// To use, make sure boids have .momentum_x and .momentum_y members.
				// Uncomment the block below and comment out the current physics code
				// Momentum is physically more accurate in outer space, but looks weird
				// for "underwater" feel we are going for. Using the simpler intertia/angle
				// system looks more like what you expect from a hydrodynamic system.
				
				// adjust pointing angle based on spin (angular momentum)
				// this.angle += (delta * this.angmo) % Math.PI;
				// // apply current inertia to our momentum
				// sinAngle = Math.sin(this.angle);
				// cosAngle = Math.cos(this.angle);
				// this.momentum_x += delta * this.inertia * cosAngle;
				// this.momentum_y += delta * this.inertia * sinAngle;
				// // translate position based on momentum
				// this.x += delta * this.momentum_x;
				// this.y += delta * this.momentum_y;
				// // dragging on walls kill momentum / intertia
				// if ( this.x < 0 ) { this.inertia *= 0.75; this.momentum_x = 0; }
				// if ( this.y < 0 ) { this.inertia *= 0.75; this.momentum_y = 0; }
				// if ( this.x > world.width ) { this.inertia *= 0.75; this.momentum_x = 0; }
				// if ( this.y > world.height ) { this.inertia *= 0.75; this.momentum_y = 0; }	
				// // stay inside world bounds			
				// this.x = clamp( this.x, 0, world.width );
				// this.y = clamp( this.y, 0, world.height );
				// // viscosity slows down inertia over time
				// const drag = (1 - ( world.settings.viscosity * delta * 10 ) );
				// this.momentum_x *= drag;
				// this.momentum_y *= drag;
				// this.inertia *= drag;
				// this.angmo *= drag;
				// // max speed caps
				// const absolute_max_speed = 2000;
				// if ( this.momentum_x > absolute_max_speed ) { this.momentum_x = absolute_max_speed; }
				// if ( this.momentum_x < -absolute_max_speed ) { this.momentum_x = -absolute_max_speed; }
				// if ( this.momentum_y > absolute_max_speed ) { this.momentum_y = absolute_max_speed; }
				// if ( this.momentum_y < -absolute_max_speed ) { this.momentum_y = -absolute_max_speed; }
				// if ( this.inertia > this.maxspeed ) { this.inertia = this.maxspeed; }
				// if ( this.inertia < -this.maxspeed ) { this.inertia = -this.maxspeed; }
				// if ( this.inertia > -5 && this.inertia < 5 ) { this.inertia = 0; } // come to a stop before end of universe
				// if ( this.angmo > this.maxrot ) { this.angmo = this.maxrot; }
				// if ( this.angmo < -this.maxrot ) { this.angmo = -this.maxrot; }
				// if ( this.angmo > -0.05 && this.angmo < 0.05 ) { this.angmo = 0; }
				
				// INERTIA-BASED MOVEMENT: ignores momentum physics
				
				// update pointing angle based on spin
				sinAngle = Math.sin(this.angle);
				cosAngle = Math.cos(this.angle);
				// [!]TECHNICAL: Javascript `%` operator is NOT mathematically strict modulus and behaves badly on negative numbers!
				this.angle = mod( this.angle + (delta * this.angmo), 2*Math.PI );
				// move forward or backward
				this.x += delta * this.inertia * cosAngle;
				this.y += delta * this.inertia * sinAngle;
				// hitting walls causes artificial drag
				if ( this.x < 0 ) { this.inertia *= 0.75; }
				if ( this.y < 0 ) { this.inertia *= 0.75; }
				if ( this.x > world.width ) { this.inertia *= 0.75; }
				if ( this.y > world.height ) { this.inertia *= 0.75; }				
				// stay inside world bounds
				this.x = clamp( this.x, 0, world.width );
				this.y = clamp( this.y, 0, world.height );
				// update drawing geometry
				this.container.position.x = this.x;
				this.container.position.y = this.y;
				this.container.rotation = this.angle;
				// viscosity slows down inertia over time
				this.inertia *= (1 - ( world.settings.viscosity * delta * 10 ) );
				this.angmo *= (1 - ( world.settings.viscosity * delta * 10 ) );
				// speed caps
				if ( this.inertia > this.maxspeed ) { this.inertia = this.maxspeed; }
				if ( this.inertia < -this.maxspeed ) { this.inertia = -this.maxspeed; }
				if ( this.inertia > -5 && this.inertia < 5 ) { this.inertia = 0; } // come to a stop before end of universe
				if ( this.angmo > this.maxrot ) { this.angmo = this.maxrot; }
				if ( this.angmo < -this.maxrot ) { this.angmo = -this.maxrot; }
				if ( this.angmo > -0.05 && this.angmo < 0.05 ) { this.angmo = 0; }
			}
			ActivateMotor( i, amount=1 ) {
				let m = this.motors[i];
				if ( m ) {
					if ( m.min && amount < m.min ) { return; }
					amount = clamp(amount,0,1);
					if ( m.hasOwnProperty('linear') ) {
						this.inertia += m.linear * amount;
					}
					if ( m.hasOwnProperty('angular') ) {
						this.angmo += m.angular * amount;
					}
				}
			}
			Kill() {
				two.remove([this.path,this.container]);
				two.remove(this.sensors.map(x=>x.geo));
				this.dead = true;
			}
		};
		
		class Boid extends ProtoBoid {
			constructor( x=0, y=0 ) {
				super(x,y);
				this.species = 'Boid';
				this.maxspeed = 600;
				this.maxrot = 8;
				this.length = 30;
				this.width = 15;
				this.energy_cost = 0.15;
				this.MakeGeometry();
				this.MakeMotors();
				this.MakeSensors();
				this.MakeBrain( 13, 6, 4, 200 );
			}
			MakeGeometry() {
				this.path = two.makePath( 
					this.length/2,0,
					-this.length/2,
					this.width/2, 
					-this.length/2,
					-this.width/2 
					);
				this.path.stroke = '#AEA';
				this.path.fill = 'transparent';
				this.path.linewidth = 2;
				this.container.add([this.path]);
			}
			MakeMotors() {
				this.motors = [
					{name:'Forward', linear:200, on:false, min:0.08 },
					{name:'Backward', linear:-100, on:false, min:0.08 },
					{name:'Rotate CW', angular:3, on:false, min:0.08 },
					{name:'Rotate CCW', angular:-3, on:false, min:0.08 }
				];
			}
			MakeSensors() { 
				const max_sensor_distance = 2.5;
				const sensor_radius = Math.max(this.length,this.width) * max_sensor_distance;
				const sensor_radius_scale = 1.25;
				// radial directional awareness sensors
				for ( let i=0, n=6; i < n; i++ ) {
					let angle = 2 * i * (Math.PI / n);
					let sensor = {
						x: 2 * sensor_radius * Math.cos(angle), 
						y: 2 * sensor_radius * Math.sin(angle), 
						r: sensor_radius * sensor_radius_scale,
						angle: angle,
						val:0,
						type:"proximity",
					};
					sensor.geo = two.makeCircle(sensor.x,sensor.y,sensor.r);
					this.sensors.push(sensor);
				}
				// inner proximity sensor
				this.sensors.push( {
					x: 0, 
					y: 0, 
					r: sensor_radius * sensor_radius_scale,
					angle: 0,
					val:0,
					type:"touch",
					geo: two.makeCircle(0,0,sensor_radius * sensor_radius_scale)
				});	
				// outer general awareness sensor			
				const outerlimit = 1.5 * ( 2*sensor_radius + sensor_radius*sensor_radius_scale );
				this.sensors.push( {
					x: 0, 
					y: 0, 
					r: outerlimit,
					angle: 0,
					val:0,
					type:"awareness",
					geo: two.makeCircle(0,0,outerlimit)
				});	
				// visualization	
				this.sensor_group.add( this.sensors.map( i => i.geo ) );
				this.sensor_group.linewidth = 1;
				this.sensor_group.stroke = '#AAEEAA55';
				this.sensor_group.fill = 'transparent';				
			}
			Kill() {
				two.remove([this.path,this.container]);
				two.remove(this.sensors.map(x=>x.geo));
				this.dead = true;
			}
			NeuroInputs() {
				const inputs = this.sensors.map(s=>s.val);
				inputs.push(this.angle / (2*Math.PI) );
				inputs.push((this.angmo + this.maxrot) / (2*this.maxrot));
				// inputs.push(this.energy);
				inputs.push((this.inertia + this.maxspeed) / (2*this.maxspeed));
				// edge detection - to be removed later - replace with actual collision detection
				// const margin = 100;
				// let nearness = 0; 
				// nearness += this.x < margin ? (margin - this.x) : 0;
				// nearness += this.x > (world.width-margin) ? (margin-(world.width - this.x)) : 0;
				// nearness += this.y < margin ? (margin - this.y ) : 0;
				// nearness += this.y > (world.height-margin) ? (margin-(world.height - this.y)) : 0;
				// nearness /= margin*2;
				// inputs.push(nearness);
				// inputs.push(Math.random()); // chaos to prevent one-track minds
				inputs.push(this.x / world.width);
				inputs.push(this.y / world.height);					
				return inputs;
			}
			NeuroInputLabels() {
				return [
					'proximity 1',
					'proximity 2',
					'proximity 3',
					'proximity 4',
					'proximity 5',
					'proximity 6',
					'touch',
					'awareness',
					'angle',
					'spin',
					'inertia',
					'world X',
					'world Y',
					// 'edges',
					// 'chaos'
				];
			}
		};
		
		class Simpleton extends ProtoBoid {
			constructor(x,y) {
				super(x,y);
				this.species = 'Simpleton';
				this.maxspeed = 400;
				this.maxrot = 8;
				this.length = 12;
				this.width = 20;
				this.energy_cost = 0.3;
				this.MakeGeometry();
				this.MakeMotors();
				this.MakeSensors();				
				this.MakeBrain( 5, 20, 3, 40 );
			}
			MakeGeometry() {
				this.path = two.makeRectangle(0,0,this.width,this.length); 
				this.path.stroke = '#2DF';
				this.path.fill = 'transparent';
				this.path.linewidth = 2;
				this.container.add([this.path]);
			}			
			MakeMotors() {
				this.motors = [
					{name:'Forward', linear:100, on:false },
					{name:'Rotate CW', angular:4, on:false },
					{name:'Rotate CCW', angular:-4, on:false }
				];
			}
			MakeSensors() {
				const max_sensor_distance = 2.5;
				const sensor_radius = Math.max(this.length,this.width) * max_sensor_distance;
				const sensor_radius_scale = 0.75;
				// inner touch sensor
				this.sensors.push( {
					x: 0, 
					y: 0, 
					r: sensor_radius * sensor_radius_scale,
					angle: 0,
					val:0,
					type:"touch",
					geo: two.makeCircle(0,0,sensor_radius * sensor_radius_scale)
				});	
				// forward proximity sensor
				this.sensors.push( {
					x: sensor_radius * max_sensor_distance, 
					y: 0, 
					r: sensor_radius * 1.5,
					angle: 0,
					val:0,
					type:"touch",
					geo: two.makeCircle(sensor_radius * max_sensor_distance,0,sensor_radius * 1.5)
				});	
				// outer general awareness sensor			
				const outerlimit = 1.5 * ( 2*sensor_radius + sensor_radius*sensor_radius_scale );
				this.sensors.push( {
					x: 0, 
					y: 0, 
					r: outerlimit,
					angle: 0,
					val:0,
					type:"awareness",
					geo: two.makeCircle(0,0,outerlimit)
				});				
				// visualization	
				this.sensor_group.add( this.sensors.map( i => i.geo ) );
				this.sensor_group.linewidth = 1;
				this.sensor_group.stroke = '#AAEEAA55';
				this.sensor_group.fill = 'transparent';							
			}
			NeuroInputs() {
				const inputs = this.sensors.map(s=>s.val);
				inputs.push(this.angle / (2*Math.PI) );
				// inputs.push((this.angmo + this.maxrot) / (2*this.maxrot));
				// inputs.push((this.inertia + this.maxspeed) / (2*this.maxspeed));
				// edge detection - to be removed later - replace with actual collision detection
				const margin = 100;
				let nearness = 0; 
				nearness += this.x < margin ? (margin - this.x) : 0;
				nearness += this.x > (world.width-margin) ? (margin-(world.width - this.x)) : 0;
				nearness += this.y < margin ? (margin - this.y ) : 0;
				nearness += this.y > (world.height-margin) ? (margin-(world.height - this.y)) : 0;
				nearness /= margin*2;
				inputs.push(nearness);
				// inputs.push(Math.random()); // chaos to prevent one-track minds
				return inputs;
			}		
			NeuroInputLabels() {
				return [
					'inner',
					'front',
					'outer',
					'edges',
					// 'chaos'
				];
			}				
		}
		
		class Kayak extends ProtoBoid {
			constructor(x,y) {
				super(x,y);
				this.species = 'Kayak';
				this.maxspeed = 400;
				this.maxrot = 10;
				this.length = 18;
				this.width = 18;
				this.energy_cost = 0.88;
				this.MakeGeometry();
				this.MakeMotors();
				this.MakeSensors();				
				this.MakeBrain( 6, 20, 2, 50 );
			}
			MakeGeometry() {
				this.path = two.makePath( 
					-this.length/2,
					this.width/2,
					this.length/2,
					0, 
					-this.length/2,
					-this.width/2 ,
					-this.length/4,
					0, 
					);
				this.path.stroke = '#E94';
				this.path.fill = 'transparent';
				this.path.linewidth = 2;
				this.container.add([this.path]);
			}			
			MakeMotors() {
				this.motors = [
					{name:'Left Stroke', linear:200, angular:12, on:false },
					{name:'Right Stroke', linear:200, angular:-12, on:false },
				];
			}
			MakeSensors() {
				const max_sensor_distance = 2.5;
				const sensor_radius = Math.max(this.length,this.width) * max_sensor_distance;
				const sensor_radius_scale = 0.75;
				// inner touch sensor
				this.sensors.push( {
					x: 0, 
					y: 0, 
					r: sensor_radius * sensor_radius_scale,
					angle: 0,
					val:0,
					type:"touch",
					geo: two.makeCircle(0,0,sensor_radius * sensor_radius_scale)
				});	
				// forward proximity sensor
				this.sensors.push( {
					x: sensor_radius * max_sensor_distance, 
					y: 0, 
					r: sensor_radius * 1.5,
					angle: 0,
					val:0,
					type:"touch",
					geo: two.makeCircle(sensor_radius * max_sensor_distance,0,sensor_radius * 1.5)
				});	
				// outer general awareness sensor			
				const outerlimit = 1.5 * ( 2*sensor_radius + sensor_radius*sensor_radius_scale );
				this.sensors.push( {
					x: 0, 
					y: 0, 
					r: outerlimit,
					angle: 0,
					val:0,
					type:"awareness",
					geo: two.makeCircle(0,0,outerlimit)
				});				
				// visualization	
				this.sensor_group.add( this.sensors.map( i => i.geo ) );
				this.sensor_group.linewidth = 1;
				this.sensor_group.stroke = '#AAEEAA55';
				this.sensor_group.fill = 'transparent';							
			}
			NeuroInputs() {
				const inputs = this.sensors.map(s=>s.val);
				inputs.push(this.angle / (2*Math.PI) );
				inputs.push(this.x / world.width);
				inputs.push(this.y / world.height);
				// inputs.push(Math.random()); // chaos to prevent one-track minds
				return inputs;
			}	
			NeuroInputLabels() {
				return [
					'inner',
					'front',
					'outer',
					'angle',
					'world X',
					'world Y',
					// 'chaos'
				];
			}						
		}
		
		let boids = [];
		for ( let i=0; i < 1; i++ ) {
			const b = BoidFactory(world.use_species, Math.random()*world.width, Math.random()*world.height );
			// const b = BoidFactory(world.use_species, world.width*0.25,world.height*0.25 );
			b.angle = Math.random() * Math.PI * 2;
			boids.push(b);
		}
		 
		// draw screen
		two.update();
		
		
		// use delta param to supply manual deltas for simulations.
		// otherwise it will use two.js's built in delta tracking.
		function update(frameNumber, delta=0) {
			// reset sim every so often --------\/----------------
			if ( world.simulator && world.simulator.turns && frameNumber % world.simulator.turns === 0 ) { 
				// record stats
				world.simulator.round.num++;
				world.simulator.round.best_score = 0;
				world.simulator.round.avg_score = 0;
				for ( let b of boids ) {
					world.simulator.round.avg_score += b.total_sensor_score || 0;
					world.simulator.round.best_score = Math.max(b.total_sensor_score||0, world.simulator.round.best_score);
				}
				world.simulator.round.avg_score /= boids.length;
				world.simulator.best_score = Math.max(world.simulator.best_score, world.simulator.round.best_score);
				world.simulator.best_avg_score = Math.max(world.simulator.best_avg_score, world.simulator.round.avg_score);
				document.getElementById('round_output').value = world.simulator.round.num;
				document.getElementById('best_score_output').value = world.simulator.round.best_score.toFixed();
				document.getElementById('avg_score_output').value = world.simulator.round.avg_score.toFixed();
				document.getElementById('total_score_output').value = world.simulator.best_score.toFixed();
				document.getElementById('best_avg_score_output').value = world.simulator.best_avg_score.toFixed();
				world.simulator.chartdata.averages.push(world.simulator.round.avg_score);
				world.simulator.chartdata.highscores.push(world.simulator.round.best_score);
				simulatorChart.data.labels.push(world.simulator.round.num);
				simulatorChart.update();
				// remove deadbeats
				const min_score = 20;
				boids.filter( x => !x.total_sensor_score < min_score ).forEach( x=> x.Kill() );
				boids = boids.filter( x => x.total_sensor_score >= min_score );
				// sort boids by sensor score ASC
				boids.sort( (a,b) => a.total_sensor_score - b.total_sensor_score );
				// cull the herd, keep the winners
				const cullpct = 0.5;
				const numkill = Math.trunc(boids.length * 0.9);
				const killmes = boids.splice(0,numkill);
				killmes.forEach( x=> x.Kill() );
				const num_survivors = boids.length;
				// create boids to make up the difference
				let el = document.getElementById('numboids_slider');
				document.getElementById('numboids_slider_output').value = el.value;
				let n = parseInt(el.value);
				let diff = n - boids.length;
				if ( diff > 0 ) {
					for ( let i=0; i < diff; i++ ) {
						let parent = null;
						if ( num_survivors && Math.random() > 0.1 ) {
							parent = boids[ Math.trunc( Math.random() * boids.length ) ];
						}
						let species = parent ? parent.species : world.use_species;
						const b = BoidFactory(species, world.width*Math.random(),world.height*Math.random() );
						b.angle = Math.random() * Math.PI * 2;
						// the BoidFactory 'Boid',will likely be an offspring of one of the survivors,
						// but we also allow a certain percentage of newcomers to try their luck
						if ( parent ) {
							b.brain = Network.fromJSON(parent.brain.toJSON());
							for ( j=0; j < world.settings.max_mutation; j++ ) { 
								b.brain.mutate( mutation_options[ Math.trunc(Math.random() * mutation_options.length) ]);
							}
						}
						// if no survivors, it automatically has a randomly generated brain
						boids.push(b);
					}			
				}
				// reset entire population
				// let newx = Math.random() * world.width/2;
				// let newy = Math.random() * world.height;
				for ( let b of boids ) {
					b.total_sensor_score = 0;
					b.angle = Math.random() * Math.PI * 2;
					b.x = Math.random() * world.width*0.8 + world.width*0.1;
					b.y = Math.random() * world.height*0.8 + world.height*0.1;
					b.angmo = 0;
					b.inertia = 0;
				}
				// move the food
				for ( let food of foods ) {
					food.x = food.geo.position.x = (Math.random() * world.width*0.5) + (world.width*0.25)
					food.y = food.geo.position.y = (Math.random() * world.height*0.5) + (world.height*0.25);
					food.vx = Math.random() * 100 - 50;
					food.vy = Math.random() * 100 - 50;
					food.value = 100;
				}
			}
			// end simulation code ------/\--------------------------
			
			// fix delta supplied in ms
			if ( delta && delta > 1 ) { delta /= 1000; }
			delta = Math.min( (delta || two.timeDelta/1000), 0.25); // beware of spikes from pausing
			
			// update all boids
			for ( let b of boids ) {
				b.Update( delta );
			}
			
			// update food
			for ( let food of foods ) {
				food.Update(delta);
			}
			
			// UI stats
			document.getElementById('framenum_output').value = two.frameCount;
			document.getElementById('fps_output').value = (1/delta).toFixed();
			
			// braingraph the leader
			if ( world.ui.show_brainmap && !world.simulator.turbo ) {
				if ( world.braingraph ) {
					two.remove(world.braingraph);
				}
				if ( boids.length ) {
					nodetypes = {
						'LOGISTIC': { color: '#72F8E0' },
						'RELU': { color: '#5abbc9' },
						'STEP': { color: '#694fd8' },
						'GAUSSIAN': { color: '#55cec1' },
						'BENT_IDENTITY': { color: '#5ce399' },
						'SINUSOID': { color: '#a25bb0' },
						'SOFTSIGN': { color: '#8c9107' },
						'TANH': { color: '#e4880a' },
						'ABSOLUTE': { color: '#1aae7a' },
						'INVERSE': { color: '#c1ab35' },
						'BIPOLAR': { color: '#000' },
						'IDENTITY': { color: '#41ad91' },
						'TANH': { color: '#5b3b49' },
					}	
					let target = world.ui.focus_object || boids.sort( (a,b) => b.total_sensor_score - a.total_sensor_score )[0];
					TrackObject(target);
					let brain = target.brain;
					let x = world.width / 2;
					let y = world.height / 2;
					let r = Math.min( world.width, world.height ) / 2.2;
					let a = (Math.PI * 2) /  brain.nodes.length;
					let node_r = 25;
					world.braingraph = two.makeGroup();
					for ( let c of brain.connections ) {
						let node1 = c.from;
						let node2 = c.to;
						let line = two.makeLine(node1.my_x, node1.my_y, node2.my_x, node2.my_y);
						let v = Math.trunc( Math.abs( clamp(c.weight,-0.1,0.1) ) * (256/10) * 100 );
						line.stroke = (c.weight > 0 ? '#FFFFFF' : '#DD1111') + DecToHex(v);
						line.linewidth = 1;
						world.braingraph.add(line);
					}
					let output_i = 0;
					let input_i = 0;
					const input_labels = target.NeuroInputLabels();
					for ( let i=0; i < brain.nodes.length; i++ ) {
						let node = brain.nodes[i];
						node.my_a = a * i;
						node.my_x = x + Math.cos(node.my_a) * r;
						node.my_y = y + Math.sin(node.my_a) * r;
						let activation_label = node.activation.toFixed(2);
						// let rect = two.makeRectangle(node.my_x, node.my_y, node_r*2, node_r*2);
						let rect = null;
						if ( node.type == 'input' ) {
							rect = two.makePolygon(node.my_x, node.my_y, node_r, 3);
							let text = two.makeText( input_labels[input_i++] + ' ' + activation_label, node.my_x, node.my_y, { fill: '#FFF' } );
							text.position.y -= node_r + 8;
							world.braingraph.add(text);
						}
						else if ( node.type == 'output' ) {
							rect = two.makePolygon(node.my_x, node.my_y, node_r, 4);
							let text = two.makeText( target.motors[output_i++].name + ' ' + activation_label, node.my_x, node.my_y, { fill: '#FFF' } );
							text.position.y -= node_r + 8;
							world.braingraph.add(text);
						}
						else {
 							rect = two.makeCircle(node.my_x, node.my_y, node_r);
							let text = two.makeText( node.squash.name + ' ' + activation_label, node.my_x, node.my_y, { fill: '#FFF' } );
							text.position.y -= node_r + 8;
							world.braingraph.add(text);
						}
						let hexval = DecToHex( Math.round(Math.abs(clamp(node.activation,-1,1)) * 255) );
						rect.fill = node.activation >= 0 
							? ('#00' + hexval + '00') 
							: ('#' + hexval + '0000') ;
						rect.stroke = nodetypes[node.squash.name]?.color ?? '#999' ;
						rect.linewidth = 5;
						world.braingraph.add(rect);
					}
					// console.log(brain.connections[0]);
				}
			}
			else {
				if ( world.braingraph ) { two.remove(world.braingraph); }
				StopTrackObject();
			}
			
		}		
		
		
		
		function clamp( x, min=null, max=null ) {
			if ( min !== null ) { x = Math.max(x,min); }
			if ( max !== null ) { x = Math.min(Math.max(x,min),max); }
			return x;
			}
			
		function RunSimulator()	{
			if ( world.simulator.round.num <= world.simulator.rounds && world.simulator.turbo ) {
				if ( two.playing ) { two.pause(); }
				for ( n=0; n < 100; n++ ) {
					++two.frameCount; // fake it
					update( two.frameCount, 0.055 );
				}
				--two.frameCount;
				two.update();
				setTimeout( RunSimulator, 0 );
			}
			else {
				two.play();
			}
		}
		
		
		
		//
		//
		two.play();
	  	//
		//	
			
		function TrackObject(o) {
			if ( !o ) { return; }
			if ( o.dead ) { StopTrackObject(o); return; }
			world.ui.focus_object = o;
			if ( !world.ui.focus_geo ) {
				world.ui.focus_geo = two.makeCircle(world.ui.focus_object.x, world.ui.focus_object.y, 50);
				world.ui.focus_geo.stroke = '#AEA';
				world.ui.focus_geo.linewidth = 4;
				world.ui.focus_geo.fill = 'transparent';
			}
			else {
				world.ui.focus_geo.position.x = world.ui.focus_object.x;
				world.ui.focus_geo.position.y = world.ui.focus_object.y;
			}
		}
		function StopTrackObject() {
			if ( !world.ui.focus_object ) { return ; }
			world.ui.focus_object = null;
			two.remove([world.ui.focus_geo]);
			world.ui.focus_geo = null;
		}
		function ShiftFocusTarget() {
			if ( !boids.length ) { return; }
			if ( !world.ui.focus_object ) { 
				TrackObject(boids[0]);
			}
			else {
				let i = boids.indexOf( world.ui.focus_object );
				if ( ++i == boids.length ) { i = 0; }
				TrackObject( boids[i] );
			}
		}
			
		function ChangeCulling() {
			let el = document.getElementById('culling_slider');
			world.settings.cullpct = el.value;
			document.getElementById('culling_slider_output').value = el.value;
		}
		
		function ChangeViscosity() {
			let el = document.getElementById('viscosity_slider');
			world.settings.viscosity = el.value;
			document.getElementById('viscosity_slider_output').value = el.value;
		}
			
		function ChangeMutation() {
			let el = document.getElementById('mutation_slider');
			world.settings.max_mutation = el.value;
			document.getElementById('mutation_slider_output').value = el.value;
		}
		
		function ChangeNumBoids(x) {
			let el = document.getElementById('numboids_slider');
			let n = parseInt(x) || parseInt(el.value);
			document.getElementById('numboids_slider_output').value = n;
			el.value = n;
			let diff = n - boids.length;
			if ( diff > 0 ) {
				for ( let i=0; i < diff; i++ ) {
					const b = BoidFactory(world.use_species, Math.random()*world.width, Math.random()*world.height );
					b.angle = Math.random() * Math.PI * 2;
					boids.push(b);
				}			
			}
			else if ( diff < 0 ) {		
				boids.splice(0,-diff).forEach( x => x.Kill() );
			}
		}
		

		function SetShowUI(x) {
			world.ui.show_ui = !!x;
			let el = document.getElementById('ui_container');
			if ( world.ui.show_ui ) { el.style.visibility = 'visible'; }
			else { el.style.visibility = 'hidden'; }
		}
		function ToggleUI() {
			SetShowUI( !world.ui.show_ui );
		}
		function SetShowSensors(x) {
			world.ui.show_collision_detection = !world.ui.show_collision_detection;
		}
		function ToggleShowSensors() {
			SetShowSensors( !world.ui.show_collision_detection );
		}
		function ToggleShowBrainmap() {
			world.ui.show_brainmap = !world.ui.show_brainmap;
		}
		function ToggleSimulatorFF() {
			world.simulator.turbo = !world.simulator.turbo;
			if ( world.simulator.turbo ) { RunSimulator(); }
		}
		function TogglePause() {
			if ( two.playing ) { two.pause(); console.log('paused'); } 
			else { two.play(); console.log('playing'); }
		}
		
		
		window.onresize = function(event) {
			world.height = window.innerHeight / world.scale;
			world.width = window.innerWidth / world.scale;
			two.fit();
		}
		
		document.getElementById('hide_ui_button').addEventListener('click', function(event) {
			event.preventDefault();
			ToggleUI();
			return false;
		});
		
		document.getElementById('pause_button').addEventListener('click', function(event) {
			TogglePause();
			return false;
		});
		
		document.getElementById('show_sensors_button').addEventListener('click', function(event) {
			ToggleShowSensors();
			return false;
		});
		
		document.getElementById('fast_forward_button').addEventListener('click', function(event) {
			ToggleSimulatorFF();
			return false;
		});
		
		document.getElementById('show_brainmap_button').addEventListener('click', function(event) {
			ToggleShowBrainmap();
			return false;
		});
		
		document.getElementById('save_leader_button').addEventListener('click', function(event) {
			SaveLeader();
			return false;
		});
		
		document.getElementById('load_leader_button').addEventListener('click', function(event) {
			LoadLeader();
			return false;
		});
		
		
		ChangeViscosity();
		ChangeNumBoids(30);
		ChangeMutation();
		ChangeCulling();
		SetShowUI(world.ui.show_ui);
			
			
		// Handle key down events
		const body = document.querySelector("body");
		body.addEventListener("touchstart", function(event) {
			if ( !world.ui.show_ui ) ToggleUI();
		});
		body.addEventListener("keydown", function(event) {
			if ( event.keyCode == 19 ) {  // `Pause` 
				TogglePause();
			}
			else if ( event.keyCode == 39 ) {  // `right arrow` 
				event.preventDefault();
				ShiftFocusTarget();
			}
			else if ( event.which == 49 ) {  // `1` 
				event.preventDefault();
				ToggleShowSensors();
			}
			else if ( event.which == 50 ) {  // `2` 
				event.preventDefault();
				ToggleUI()
			}
			else if ( event.which == 66 ) {  // `B` 
				event.preventDefault();
				ToggleShowBrainmap()
			}
			else if ( event.which == 51 ) {  // `3` 
				event.preventDefault();
				SaveLeader();
			}
			else if ( event.which == 52 ) {  // `4` 
				event.preventDefault();
				LoadLeader();
			}
			else if ( event.which == 35 ) {  // `END` 
				event.preventDefault();
				ToggleSimulatorFF();
			}
		});
			
		function SaveLeader() {
			if ( boids.length ) {
				const b = boids.sort( (a,b) => b.total_sensor_score - a.total_sensor_score )[0];
				localStorage.setItem("leader-brain", JSON.stringify(b.brain.toJSON()));
				console.log("Saved leader brain with score " + b.total_sensor_score.toFixed(1) );
			}		
		}
		
		function LoadLeader() {
			let json = localStorage.getItem("leader-brain");
			if (json) {
				json = JSON.parse(json);
				let brain = Network.fromJSON(json);
				const b = BoidFactory(world.use_species, Math.random()*world.width, Math.random()*world.height );
				b.brain = brain;
				b.angle = Math.random() * Math.PI * 2;		
				boids.push(b);				
				console.log("Spawned saved brain" );
			}		
		}
			
			
		//
		// UTILS ------------------------\/-----------------
		//
		
		function DecToHex( n ) { 
			n = n.toString(16);
			if ( n.length % 2 ) { n = '0' + n; }
			return n;
			}
			
		function HexToDec( n ) { 
			return parseInt(n, 16);
			}


		// converts "#000000" -> "rgb(x,y,z)"
		function HexColorToRGB( hex ) {
			hex = hex.replace('#','').trim();
			let str = 'rgb(';
			str += HexToDec(hex.substr(0,2)) + ',';
			str += HexToDec(hex.substr(2,2)) + ',';
			str += HexToDec(hex.substr(4,2)) + ')';
			return str;
			}
			
		// converts "#000000" -> [x,y,z]
		function HexColorToRGBArray( hex ) {
			hex = hex.replace('#','').trim();
			// convert shorthand to longhand
			if ( hex.length <= 4 ) {
				hex = hex.split('').map( p => p+p ).join('');
			}			
			let arr = [
				HexToDec(hex.substr(0,2)),
				HexToDec(hex.substr(2,2)),
				HexToDec(hex.substr(4,2)),
				]
			return arr;
			}
			
		// converts [x,y,z] -> "#000000"
		function RGBArrayToHexColor( arr ) {
			let str = '#' +
				DecToHex(arr[0]) +
				DecToHex(arr[1]) +
				DecToHex(arr[2]) ;
			return str;
			}
			
		// converts "rgb(x,y,z)" -> "#000000"
		function RGBToHexColor( rgb ) {
			let matches = rgb.match(/(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
			let str = '#';
			str += DecToHex( matches[1] || 1 );
			str += DecToHex( matches[2] || 1 );
			str += DecToHex( matches[3] || 1 );
			return str;
			}
			
			
		function angleToPoint(x1, y1, x2, y2){
			d = distance(x1, y1, x2, y2);
			dx = (x2-x1) / d;
			dy = (y2-y1) / d;
			a = Math.acos(dx);
			a = dy < 0 ? 2 * Math.PI - a : a;
			return a;
		}
		
		function mod (n, m) { return (n % m + m) % m; }
		
	</script>
		
</body>
</html>